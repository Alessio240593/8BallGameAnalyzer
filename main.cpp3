#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main() {
    // Load the video
    VideoCapture cap("billiard_video.mp4");
    if (!cap.isOpened()) {
        cout << "Error: Unable to open video file" << endl;
        return -1;
    }

    // Parameters for Shi-Tomasi corner detection
    vector<Point2f> p0, p1;
    int maxCorners = 100;
    double qualityLevel = 0.3;
    double minDistance = 7;
    int blockSize = 7;
    bool useHarrisDetector = false;
    double k = 0.04;

    // Parameters for Lucas-Kanade optical flow
    TermCriteria criteria = TermCriteria((TermCriteria::COUNT) + (TermCriteria::EPS), 10, 0.03);
    Size winSize = Size(15, 15);
    int maxLevel = 2;

    // Create some random colors
    vector<Scalar> colors;
    RNG rng;
    for (int i = 0; i < maxCorners; i++) {
        colors.push_back(Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255)));
    }

    // Take first frame and find corners in it
    Mat old_frame, old_gray;
    cap >> old_frame;
    cvtColor(old_frame, old_gray, COLOR_BGR2GRAY);
    goodFeaturesToTrack(old_gray, p0, maxCorners, qualityLevel, minDistance, Mat(), blockSize, useHarrisDetector, k);

    // Create a mask image for drawing purposes
    Mat mask = Mat::zeros(old_frame.size(), old_frame.type());

    while (true) {
        Mat frame, frame_gray;
        bool bSuccess = cap.read(frame);
        if (!bSuccess) {
            cout << "Video is completed" << endl;
            break;
        }
        cvtColor(frame, frame_gray, COLOR_BGR2GRAY);

        // Calculate optical flow
        vector<uchar> status;
        vector<float> err;
        calcOpticalFlowPyrLK(old_gray, frame_gray, p0, p1, status, err, winSize, maxLevel, criteria);

        // Select good points
        vector<Point2f> good_new;
        for (uint i = 0; i < p0.size(); i++) {
            if (status[i] == 1) {
                good_new.push_back(p1[i]);
                line(mask, p1[i], p0[i], colors[i], 2);
                circle(frame, p1[i], 5, colors[i], -1);
            }
        }

        Mat img;
        add(frame, mask, img);

        imshow("Frame", img);
        int keyboard = waitKey(30);
        if (keyboard == 'q' || keyboard == 27) {
            break;
        }

        // Update the previous frame and previous points
        old_gray = frame_gray.clone();
        p0 = good_new;
    }

    cap.release();
    destroyAllWindows();
    return 0;
}
